# FastAPI Application

This is the layer of the bot that deals with the database and other services directly.

# Database

The database table definitions are found in `./api/db/tables.py`.

These are SQLAlchemy table models.

Each one defines its table name, any constraints, and all columns present in that table.

It is important that each constraint includes a specific name, even ones like Primary Keys and Unique Keys that can be set directly from `mapped_column`. This is for database migration purposes with alembic.

```py
class Entry(BaseTable):
    __tablename__ = "entries"
    __table_args__ = (
        PrimaryKeyConstraint("id", name="entries_pk"),
    )

    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(45), nullable=False)
```

# Areas
Areas are how we categorize our routes. For example, if you have many routes pertaining to `users` (i.e. creating, updating, deleting, etc.), then those would go in a `areas/users` directory.

Each area contains 3 python files.
- `models.py`
  - This contains pydantic definitions for the inputs and outputs for that area's endpoints.
- `view.py`
  - This is simply where the endpoints themselves are defined.
  - Most real logic will go in `repository.py`
- `repository.py`
  - This is where "business logic" goes, and where the database is written to/read from.

This follows a fairly standard model/view/controller structure as seen in many production environments.

The `router` for each area's view is then included in `./api/core/router.py` like such:

```py
router.include_router(entry_router, prefix="/entries", tags=["entries"])
```

# Models

Models are defined as [pydantic](https://docs.pydantic.dev/latest/) models, which extend our custom `BaseAppModel` from `core/base_classes.py`. This would be an example `model.py` file for reading and writing to/from the database.

```py
from typing import Annotated
from pydantic import Field
from core.base_classes import BaseAppModel

class EntryBase(BaseAppModel):
    name: Annotated[str, Field(max_length=45)]

class EntryPublic(EntryBase):
    id: int

class EntryCreate(EntryBase):
    pass

class EntryUpdate(EntryBase):
    pass
```

- `*Base` is the class all the others are extended from
- `*Public` is the one that is exposed as the endpoint responses
- `*Create` is the input model for creating the object
- `*Update` is the input model for updating the object

This is not the only possible configuration for the models, but it is recommended to stay similar to it.

Note the use of `Annotated` to define the specific `Field` restrictions. This is the recommended way to configure these.


# Views

The views are where endpoints are defined.

They are ["Class Based Views"](https://fastapi-restful.netlify.app/user-guide/class-based-views/#the-cbv-decorator) which allows us to define FastAPI dependencies like the Repository classes (see below) to be shared between all the endpoints without repetition of code.

Following our `entry` examples, this is the `view.py` associated.
```py
from fastapi import Depends
from fastapi_utils.cbv import cbv
from fastapi_utils.inferring_router import InferringRouter

from .repository import EntryRepository
from .models import EntryCreate, EntryPublic
from db.tables import Entry

router = InferringRouter()

@cbv(router)
class EntryRouter:

    # Dependencies
    entry_repository: EntryRepository = Depends(EntryRepository)

    # Routes
    @router.post("/", response_model=EntryPublic)
    async def create_entry(self, entry: EntryCreate) -> Entry:
        return await self.entry_repository.create_entry(name=entry.name)
```

Note that `self.entry_repository` is used, allowing the dependency to be injected without having been specified in the endpoint directly.

# Alembic (Database Migrations)

Database migrations are handled by Alembic. 

Any time a change is made to the `tables.py` definitions for the database tables, it can be autogenerated as a migration by running `just api revise <revision_message>`. 

Then, to apply the migration it's as simple as running `just api migrate`. 

To undo the last (one) revision, you can run `just api rollback`.

If there is important data in the database, it is recommended to manually review the generated revisions in the `./api/alembic/versions` directory.