# FastAPI Application

This is the layer of the bot that deals with the database and other services directly.

# Database

The database table definitions are found in `./api/db/tables.py`.

These are SQLAlchemy table models.

Each one defines its table name, any constraints, and all columns present in that table.

It is important that each constraint includes a specific name, even ones like Primary Keys and Unique Keys that can technically be set directly from `mapped_column`. This is for database migration purposes with alembic.

```py
class Entry(BaseTable):
    __tablename__ = "entries"
    __table_args__ = (
        PrimaryKeyConstraint("id", name="entries_pk"),
        UniqueConstraint("name", name="entries_name_uq"),
    )

    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(45), nullable=False)
```

# Areas
Areas are how we categorize our routes. For example, if you have many routes pertaining to `users` (i.e. creating, updating, deleting, etc.), then those would go in a `areas/users` directory.

Each area contains 3 python files.
- `models.py`
  - This contains any needed pydantic definitions for the inputs and outputs of that area's endpoints.
- `view.py`
  - This is simply where the endpoints themselves are defined.
  - Most real logic will go in `repository.py`
- `repository.py`
  - This is where "business logic" goes, and where the database is written to/read from.

This follows a fairly standard model/view/controller structure as seen in many production environments.

The `router` for each area's view is then included in `./api/core/router.py` like such:

```py
router.include_router(entry_router, prefix="/entries", tags=["entries"])
```

The tags allow us to easily organize them when viewing the generated docs, and when generating typescript code.

# Models

Models are defined as [pydantic](https://docs.pydantic.dev/latest/) models, which extend the custom `BaseAppModel` from `core/base_classes.py`. This would be an example `model.py` file for reading and writing to/from the database.

```py
from typing import Annotated
from pydantic import Field
from core.base_classes import BaseAppModel

class EntryBase(BaseAppModel):
    name: Annotated[str, Field(max_length=45)]

class EntryPublic(EntryBase):
    id: int

class EntryCreate(EntryBase):
    pass

class EntryUpdate(EntryBase):
    pass
```

- `*Base` is the class all the others are extended from
- `*Public` is the one that is exposed as the endpoint responses
- `*Create` is the input model for creating the object
- `*Update` is the input model for updating the object

These are not strictly required, and are not the only possible configuration for the models, but it is recommended to stay similar to it.

Note the use of `Annotated` to define the specific `Field` restrictions. This is the recommended way to configure these.

# Views

The views are where endpoints are defined.

They are ["Class Based Views"](https://fastapi-restful.netlify.app/user-guide/class-based-views/#the-cbv-decorator) which allows us to define FastAPI dependencies like the Repository classes (see below) to be shared between all the endpoints without repetition of code.

Following our `entry` examples, this is the `view.py` associated.
```py
from fastapi import Depends
from fastapi_utils.cbv import cbv
from fastapi_utils.inferring_router import InferringRouter

from .repository import EntryRepository
from .models import EntryCreate, EntryPublic
from db.tables import Entry

router = InferringRouter()

@cbv(router)
class EntryRouter:

    # Dependencies
    entry_repository: EntryRepository = Depends(EntryRepository)

    # Routes
    @router.post(
        "/",
        response_model=EntryPublic,
        operation_id="createEntry",
        summary="Create a new entry.",
    )
    async def create_entry(self, entry: EntryCreate) -> Entry:
        return await self.entry_repository.create_entry(name=entry.name)

```

- `response_model` is the class from `.models` that  exposes any information that should be visible to the bot.<br/>
- `operation_id` is the raw openapi name for the endpoint. This must be unique across all endpoints, and is what the resulting function will be named when generated into typescript.
- `summary` is a basic summary of the endpoint's function.

# Alembic (Database Migrations)

Database migrations are handled by Alembic. 

Any time a change is made to the `tables.py` definitions for the database tables, it can be autogenerated as a migration by running `just api revise <revision_message>`. 

Then, to apply all un-applied migrations, it's as simple as running `just api migrate`. 

To undo the last (one) revision, you can run `just api rollback`.

For more advanced usage, reference the alembic docs to use the commands directly.

> [!Warning]
> If there is important data in the database, it is highly recommended to manually review the generated revisions in the `./api/alembic/versions` directory before running them.